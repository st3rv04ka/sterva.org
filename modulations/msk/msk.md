# MSK

MSK (**Minimum Shift Keying**) - вид частотной модуляции с минимальным разносом частот. Это более продвинутая версия CPFSK модуляции, которая имеет непрерывную фазу, но у которой индекс модуляции, отвечающий за расстояние между частотами для нуля и единицы, минимален.

# Модуляция MSK

Перед переходом к MSK рекомендую ознакомиться с CPFSK и FSK модуляциями. Ссылки на эти модуляции можно найти на главной странице моего сайта. Главным отличием MSK от CPFSK является ширина спектра. В MSK он минимален, что позволяет использовать все плюсы CPFSK и занимать еще меньше полосы пропускания. Разберемся немного лучше на что влияет индекс модуляции и где найти его в формулах. При обычной CPFSK модуляции мы выбираем базовую частоту и уже на ее основе определяем две другие частоты, одну для нуля, вторую для единицы. 
$$
w_{base} = 50 \\
w_{deviation} = pi * (1/Tb) * fsk_{index}
$$
В приведенных формулах Tb - это длительность одного бита, а fsk_index и есть тот индекс, которым отличается CPFSK от MSK. Этот индекс напрямую влияет на разнос частот. Как видно из формул - чем больше индекс, тем больше разнос частот. Стандартные значения этого индекса: 1, 2, 3, 5. Посмотрим как меняется разнос частот в CPFSK при изменении этого индекса. Длительность одного бита будет равна 1 секунде.

```octave
Fs = 1000;
Tb = 1;
t = 0:1/Fs:Tb-1/Fs;

fsk_indices = [0.1, 0.5, 1, 3, 5];
w_base = 50;
figure;

for idx = 1:length(fsk_indices)
    fsk_index = fsk_indices(idx);
    w_deviation = pi * (1/Tb) * fsk_index;

    w0 = w_base - w_deviation;
    w1 = w_base + w_deviation;

    bits = [0 1 0 0 1 0 0 0 0 1 1 0 0 1];

    phase = 0;
    CPFSK_signal = [];
    for i = 1:length(bits)
        if bits(i) == 0
            freq = w0;
        else
            freq = w1;
        end
        for j = 1:length(t)
            phase = phase + freq / Fs;
            CPFSK_signal = [CPFSK_signal cos(phase)];
        end
    end

    N = length(CPFSK_signal);
    f = (-N/2:N/2-1)*(Fs/N);
    Y_CPFSK = fftshift(fft(CPFSK_signal, N));
    P_CPFSK = abs(Y_CPFSK/N);

    subplot(length(fsk_indices), 1, idx);
    plot(f, P_CPFSK);
    title(['Spectrum of CPFSK Modulated Signal (fsk\_index = ', num2str(fsk_index), ')']);
    xlabel('Frequency (Hz)');
    ylabel('|P(f)|');
    xlim([-20 20]);
end
```

При запускаем получим 5 спектров сигналов с разными fsk_index: 0.1, 0.5, 1, 3, 5. 

![spectrs](https://sterva.org/modulations/msk/spectrs.jpeg)

На графике четко видно разницу между частотами при индексе 5, но при уменьшении индекса модуляции разница становится всё меньше. В какой-то момент, а именно при 0.5, различить на спектре частоты становится очень сложно, а при 0.1 вообще невозможно, потому что они сливаются в одну. 

# Минимальный индекс модуляции

Чтобы найти нужный индекс модуляции нужно решить задачу с ортогональностью несущих частот в сигнале. **Ортогональность** - это свойство двух функций или векторов, которые взаимно перпендикулярны в простанстве состояний, что в контексте сигналов означает, что их перекрестное влияние друг на друга минимально или вообще отсутствует. То есть задача ортогональности сводится к тому, чтобы найти такие частоты с минимальным разносом, которые бы не влияли друг на друга и смогли бы быть восстановлены при приеме и демодуляции сигнала.

Для двух функций f1(t) и f2(t), которые определены на интервале [a,b], они ортогональные если их скалярное произведение равно нулю. Математически это выглядит следующим образом.
$$
\int_{a}^{b} f1(t)*f2(t) \,dt = 0
$$
Если проецировать это на сигналы, то ортогональные несущие это сигналы, чьи частоты или фазы выбраны таким образом, чтобы они были ортогональны друг другу. 

Рассмотрим пример с двумя сигналами с разными частотами. 
$$
s_1(t) = cos(2*pi*f_1*t)\\
s_2(t) = cos(2*pi*f_2*t)
$$
Эти сигналы будут ортогональными, если их скалярное произведение будет равно нулю. Подставим их в формулу с интегралом.
$$
\int_{0}^{T} cos(2*pi*f_1*t)*cos(2*pi*f_2*t) \,dt = 0
$$
Для гармонических функций с различными частотами это условие выполняется, если Т - период наименьшего общего кратного периодов двух сигналов. Интегрируя выражение получаем следующее. Заменим частоты на угловые и решим интеграл.
$$
\int_{0}^{T} cos(w_1*t)*cos(w_2*t) \,dt = 0\\
cos(w_1*t)*cos(w_2*t) = [cos((w_1-w_2)*t)+cos((w_1+w_2)*t)]/2\\
$$
Используя тригонометрическое тождество произведения косинусов и подставляем его в интеграл. Теперь можем разбить один большой интеграл на два.
$$
\frac12 \int_{0}^{T} [cos((w_1-w_2)*t)+cos((w_1+w_2)*t)] \,dt\\
\frac12 (\int_{0}^{T} [cos((w_1-w_2)*t)] \,dt + \int_{0}^{T} [cos((w_1+w_2)*t)] \,dt)\\
$$
Теперь проанализируем два интеграла отдельно. Первый интеграл.
$$
\int_{0}^{T} [cos((w_1-w_2)*t)] \,dt
$$
Интеграл косинуса будет равен нулю, если его аргумент будет равен 2pi умноженному на любое целое число. Используя это свойство получаем.
$$
(w_1-w_2) = \frac{2*pi*k}T
$$
Второй интеграл.
$$
\int_{0}^{T} [cos((w_1+w_2)*t)] \,dt
$$
Следуя прошлому правилу получаем. 
$$
(w_1+w_2) = \frac{2*pi*m}T
$$
В обоих случаях k и m - это константы отличные от нуля.

Вернемся к MSK. В MSK частоты f1 и f2 выбираются таким образом, чтобы сигналы были ортогональный. Частоты для 1 и 0 соответственно равны.
$$
f_0 = f_{base} - \Delta f\\
f_1 = f_{base} + \Delta f
$$
Где f_base - центральная частота, а delta f - девиация частоты. Tb - длительность 1 бита. Тогда, для ортогональности частот f0 и f1.
$$
(w_1 - w_2) = 2*pi*(f_1 - f_0) = \frac {2*pi*k} {T_b}\\
2*pi*((f_{base}+\Delta f) - (f_{base}-\Delta f)) = \frac {2*pi*k} {T_b}\\
2*pi*(2*\Delta f) =  \frac {2*pi*k} {T_b} \\
4*pi*\Delta f = \frac {2*pi*k} {T_b} \\
\Delta f = \frac k {2T_b}
$$
Так как k - это целое число не равное нулю, то его минимальное значение будет 1. **Именно по этой формуле рассчитывается девиация частот для MSK, FSK и CPFSK.** Она позволяет получить минимальную разницу между частотами и добиться наименьшей ширины спектра. Индекс модуляции для MSK можно получить используя формулу индекса модуляции через скорость передачи и девиацию частоты.
$$
fsk_{index} = \frac {\Delta f} {\frac 1 {T_b}} \\
fsk_{index} = \frac {\frac 1 {2*T_b}} {\frac 1 {T_b}} \\
fsk_{index} = \frac {\frac 1 {2*1}} {\frac 1 {1}} \\
fsk_{index} = \frac {0.5} 1 = 0.5\\
$$


Соответственно индекс модуляции для MSK всегда равен 0.5. Именно за счет ортогональности сигналов и низкого индекса модуляции мы получаем узкий спектр, что дает множество преимуществ MSK перед CPFSK.

# Модуляция MSK в Octave

Изучим спектральную разницу между CPFSK с индексом модуляции 1 и MSK. Для этого используем следующим код.

```octave
Fs = 1000;
Tb = 1;
t = 0:1/Fs:Tb-1/Fs;

w_base = 50;

fsk_index_cpfsk = 1;
w_deviation_cpfsk = pi * (1/Tb) * fsk_index_cpfsk;

w0_cpfsk = w_base - w_deviation_cpfsk;
w1_cpfsk = w_base + w_deviation_cpfsk;

bits = [0 1 0 0 1 0 0 0 0 1 1 0 0 1];

phase = 0;
CPFSK_signal = [];
for i = 1:length(bits)
    if bits(i) == 0
        freq = w0_cpfsk;
    else
        freq = w1_cpfsk;
    end
    for j = 1:length(t)
        phase = phase + freq / Fs;
        CPFSK_signal = [CPFSK_signal cos(phase)];
    end
end

N = length(CPFSK_signal);
f = (-N/2:N/2-1)*(Fs/N);
Y_CPFSK = fftshift(fft(CPFSK_signal, N));
P_CPFSK = abs(Y_CPFSK/N);

fsk_index_msk = 0.5;
w_deviation_msk = pi * (1/Tb) * fsk_index_msk;

w0_msk = w_base - w_deviation_msk;
w1_msk = w_base + w_deviation_msk;

phase = 0;
MSK_signal = [];
for i = 1:length(bits)
    if bits(i) == 0
        freq = w0_msk;
    else
        freq = w1_msk;
    end
    for j = 1:length(t)
        phase = phase + freq / Fs;
        MSK_signal = [MSK_signal cos(phase)];
    end
end

N = length(MSK_signal);
f = (-N/2:N/2-1)*(Fs/N);
Y_MSK = fftshift(fft(MSK_signal, N));
P_MSK = abs(Y_MSK/N);

figure;
plot(f, P_CPFSK, 'r', 'DisplayName', 'CPFSK (fsk\_index = 1)');
hold on;
plot(f, P_MSK, 'b', 'DisplayName', 'MSK (fsk\_index = 0.5)');
title('Spectr of CPFSK and MSK Modulated Signals');
xlabel('Frequency (Hz)');
ylabel('|P(f)|');
xlim([-20 20]);
legend('show');
hold off;

```

При запуске получаем следующие графики.

![spectrs](https://sterva.org/modulations/msk/cpfskvsmsk.jpeg)

Как видно спектр MSK немного уже спектра CPFSK. Это позволяет более эффективно использовать полосы частот, снизить межканальные помехи и улучшить устойчивость к шуму.

# Ресурсы

https://ru.dsplib.org/content/signal_msk/signal_msk.html#:~:text=MSK%20%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F%20%D1%8D%D1%82%D0%BE%20%D1%87%D0%B0%D1%81%D1%82%D0%BD%D1%8B%D0%B9%20%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B9,%D0%B8%20%C2%AB1%C2%BB%20(%D1%82.
https://digteh.ru/UGFSvSPS/modul/MSK/